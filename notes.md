# COURSE NOTES

## Java EE with Vaadin, JPA, Microservices, Spring and Maven

### Maven

#### Project Object Model (POM)

#### Build lifecycles and phases - clean, site, default

- Build and distribution
- Maven commands use phases and goals
- Lifecycle related phase
- Every lifecycle contains multiple phases
- Plugins execute tests, compilation
- 3 built-in build lifecycles: clean, site and default
- Usually every single maven command starts with clean because we want to remove all file generated by previous build
- mvn clean – removes target folder with the jar file
- Pre-clean, clean, post-clean
- Maven executes all the phases up to the one we invoke
- Site lifecycle – generate project’s documentation: mvn site
- Generates current proect’s site documentation
- Site Lifecycle Phases

1. Pre-site
2. Site
3. Post-site
4. Site deploy

- Maven executes all the phases upt to eh one we invoke
- Site deploy maven deploys to web server so everyone can see it
- Maven clean site and then call site command
- Maven default build lifecycle – has 23 phases
- Main phases:
  - Validate - check if all information necessary for build is available
  - Process-resources - copy the resource into target folder
  - Compile - compile the source code
  - Test - run the tests
  - Package - package compiled source code into the distributable format (jar, war, ...)
  - Integration-test - process and deploy the package if needed to run integration tests
  - Verify - run any check-ups to verify the package is valid and meets quality criteria
  - Install - install the package into the local repository
  - Deploy - copy the package to remote repository

---

#### Plugins

- Maven is a plugin execution framework, where every task is done by plugins
- Two types of plugins:
  - Build plugins: executed during build should be configured in the <build/> element of POM
  - Reporting plugins: executed during site generation configured in <reporting/> element of POM
- plugin provides set of goals
- mvn [plugin-name]:[goal-name]

---

#### Maven Repositories

A repository is a place, directory where all the project JARs, library JAR, plugins or any other project specific artifacts are stored

- Maven has 3 types of repositories

1. Local Repository - Your PC
2. Central Repository - Internet
3. Remote Repository - Some server

##### Local Repo

- Local = a directory on the computer
- gets created when we run any maven command for first time
- contains all dependencies (library JARs, plugin JARs, articfacts) maven downloads
- maven on;y needs to download the dependencies once (to the local repo), even if multiple projects depend on them
- we can chane the location of the lcoal repo in the settings.xml file
- no need for internet connection for Maven to browse local repo

  <localRepository>/path/to/local/repo</localRepository>

##### Central Repo

- provided by Maven community
- contains large number of commonly used libraries (Spring, Hibernate, etc)
- when maven doesn't find dependency in local repo it starts searching in central repo, then downoads these dependencies into local repo.
- requires internet connection
- https://search.maven.org/#browse

##### Remote Repo

- sometimes dependency is not present in local or central repo
- for this case maven provides concept of Remote rpo which is developers own custom repo containign require dlibraries or other project jars. Maven can download dependencies from this specified lcoation
- often used for hosting projects internal to organistion
- internet connection required

---

Mavn reads POM.xml file, checks if artifact is present in local repo, if it is then maven generates the jar file in the target folder, if no, check central repo, and if not remote repo.

---

### Multiple Modules

- manven supports prject aggregation in addition to project inheritance. A multi-module project is defined by a parent POM referencing one or more submodules
- extremely powerful - several teams working on modules one by one: one team database, another ui, etc.
- a multi-module project is built from a parent/aggregator POM that manages a group of submodules: ui module, db module
- the submodules are regular Maven projects, and then cab be built seperately or through the parent POM.

**Benefits of using Multi-Modules**

- only one single command is required to build all projects, including the submodules
  maven always cares about the build order for us. in most case the submodules depend on other modules
- can build and work with a single module itself.

**PARENT POM**
<packaging>pom</packaging>

- parent POM is not an executable application in itself it is just the parent of every submodule
- in parent we define the submodules within the modules stack

**SUBMODULE POM**

---

**THE REACTOR**
The mechanism in Maven that handles multi-module projects is referred to as the reactor. This part of the Maven core does the following:

- Collects all the available modules to build
- Sorts the projects into the correct build order
- Builds the selected projects in order
- ui module relies on db modules for instance, so order of compilation matters

---

### Parent POM vs Aggregator POM

#### Parent POM

- A parent POM enables you to define an inheritance style relationship between POMs
- it's used to structur the project in order to avoid redundancies and duplicate configurations
- the submodule inherits parent's configuration and dependencies
- the parent can have a packaging "jar" or "pom"

#### Aggregator POM

- Project Aggregation is similar to Project Inheritance, but instead of specifying the parent POM from the bodule, it specifies the modules from the parent POM.
- The Aggregator POM specifies which sub-projects (or modules) to build and builds them in the specified order.
- Must have packaging of type "pom"

---

**Which one do we use?**
if you have several maven projcets ad the all have similar configuraiton you can refactor your pojects by pulling out thoe similar configurations and making a parent project.

- all you have to do is let your maven projects inherit that parent project and those ocnfigariotn would then be applied to all of them
- use aggregator project when the aim is just to **manage multiple modules** (no similar configurations are present).
- in real life stuations we can have both project inheritance and project aggregation. In this case the parent specifies the modules and contains some similar features, confirguation.

---

## Section 4: Java Persistence API (JPA)

### The Old way - JDBC

- JDBC - Java Database Connectivity
- Stanard Java API for database-independent connectivtiy between the Java programming language and a wide range of databases.
- JDBC uses database specific drivers to conenct to databases
- DriverManager acts as an interface between user and drivers. Keeps treack of the drivers that are available and handles establishing a conenction beteen the database and the appropriate driver.

---

### JDBC Architecture

Java Application > JDBC API > JDBC Driver Manager > JDBC Driver (Oracle) | JDBC Driver (MS SQL) | JDBC Driver (MsSQL)

- JDBC Driver - interface acts between Java application and database
- databsae server = oracle, mssql, myssql - each require different JDBC driver

---

#### Other Important JDBC Interfaces

A **Connection** is the session between java application and database. You use objects created from Conncetion interface to submit the SQL statements to the database.

- The **Statement** interface represents the static SQL statement. It helps you to create a general purpose SQL statements using Java.
- **ResultSet** interface represents the result set of a database query. A resultSt maintains a cursor pointing to its current row of data.

---

#### Advantages of JDBC

- Conveient for small apps
- easy to use quite simplesyntax
- can read any database if proper drivers are isntalled
- creates XML structure of data from database automatically
- Query and Stored prodedure supported.
- JDBC supports modules
- Can be used for both Synchronous and Asyncrhonous processing.

---

#### Disadvantages of JDBC

- Can be very complicated when used for large applications
- No encapsulation, quite hard to implement MVC concept with it.
- It is very senstivei when it comes to the driver. Coorect drivers need to be deployed for each typ eof db.
- It does not allow single sequence to update or isnert multiple tables.
- Not so convenient, newer technologies are more developer friendly such as JPA and Hibernate.

---

- Underhood JPA and Hibernate rely heavily on JDBC.

- JDBC implementation not that convenient because we have to handle the connection, the statement, the resultSet, we have to deal with try catch blocks, close the resultSet, the connection and the statement, and we have to make sure we use the valid JDBC Driver, we have to handle the DATABASE_URL.

---

```sql
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
+--------------------+
6 rows in set (0.06 sec)

mysql> create database udemy;
Query OK, 1 row affected (0.03 sec)

mysql> use udemy;
Database changed
mysql> show tables;
Empty set (0.03 sec)

mysql> create table students(id mediumint not null auto_increment, name varchar(30) not null, age int not null, primary key(id));
Query OK, 0 rows affected (0.04 sec)

mysql> show tables;
+-----------------+
| Tables_in_udemy |
+-----------------+
| students        |
+-----------------+
1 row in set (0.01 sec)

mysql> select * from students;
Empty set (0.01 sec)

mysql> insert into students(name, age) values('Daniel', '20');
Query OK, 1 row affected (0.01 sec)

mysql> select * from students;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
|  1 | Daniel |  20 |
+----+--------+-----+
1 row in set (0.00 sec)

mysql> insert into students(name, age) values('Adam', '34');
Query OK, 1 row affected (0.01 sec)

mysql> select * from students;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
|  1 | Daniel |  20 |
|  2 | Adam   |  34 |
+----+--------+-----+
2 rows in set (0.00 sec)

mysql>
```

---

### What is JPA?

#### Why JPA Came to Be?

- Usually all apps store the informaiton in database and performance database related operations
- developers need a lot fo work to connect to databases and to sae the classes intot he right table - have to make conection between objects we have in the programming language and the database table.
- JPA reduces the database related itneractions signficantly
- has ability to map Java objects to relational models.

#### Differences between Relational and Object Models

- Java is an OOP language and object models are represnted in an interconnected graph of object format, while a relational database management system such as SQL represents data in a table (tabular) format.
- both the models were different from each other on how they load or store objects.
- while storing and retrieving an object model from a relational database, some mismatch occurs
  - a difficult example is Inheritance, this inheritance relationship cannot be reflected in SQL because there is no inheritance in SQL, so we have to handle mismatches like this.
- JPA can handle these mismatches

#### What is JPA?

- JPA is a collection of classes and methods to persistently store the vast amounts of data into a database.
- JPA has the ability to map java objects to relational models
- it helps developers to execute related operations. For example: insert, remove, update tables, and so on;

---

**Before JPA**

- Have to configure Java classes and syncronize them with the SQL database table columsn one by one.
- lots of configrations and jdbc related code becuase it has to translate java objcets to SQL tables.

**After JPA**

- JPA manages most of the configurations for us.

---

#### Why is it good to use JPA?

Basically because of Abstraction: for example makes it easy to change from Hibernate to EclipseLink.

1. Manages everything for us, it uses JDBC in background
2. we can focus on business logic
3. we can manipulate java classes and objects
4. jpa will make the mapping between java objects and relational database table.
5. it's convenient.

---

#### JPA Providers

- by itself JPA is not a tool or framework, rather it defines a set of concepts that can be implemented by any tool or framework
- JPA is only a specification that acts as a bridge between Java objects/classes and a relational database
- it cannot be used on its own, providing only a set of interfaces that define the standard persistence API, which is implemented by a JPA Provider like Hibernate, EclipseLink, or OpenJPA.

---

### JPA API Architecture

javax.persistence

Entity Transaction <->  
Entity Manager Factory <->  
Entity Manager <->  
Query <->  
Persistence <->

---

JPA API <-> Entity <-> Relational Database

---

- jpa api interfaces
- hibernate will execute the given operation

---

- **EntityManagerFactory**: a factory class of EntityManager. Creates and managers multiple EntityManager instances.
- **EntityManager**: This interface manages the persistence operations on objects. It works like factory for Query instance.
- **Entity**: Entities are the persistence objects, stored as records in the database.
- **EntityTransaction**: It has one-to-one relationship with EntityManager. For each EntityManager, operations are maintained by EntityTransaction class.
- **Persistence**: This class contains static methods to obtain EntityManagerFactory instance.
- **Query**: This interface is implemented by each JPA vendor to obtain relational objects that meet the criteria. Contains the SQL query.

---

**JPA API will define the relationship between the Java object and the underlying database columns**

---

### Object Relational Mapping (ORM)

- Connection between the Java class and the SQL table
- jpa defines the relationship between the instance variables nad the columns in the db
- orm.xml file that contains all the information, or we can configure it via annotations.

---

XML based configuration is faster, because xml does not require any compilation.

Annotation is reflection in the background which isn't so fast

Annotations is usually considered a better approach than xml bsed configration because we want to make clear what is going on under the hood

**What is object relational mapping and what are its benefits?**

1. the ability to convert data from object type to relational type and vice versa.
2. ORM binds/maps a java object to a database table - we don't have to bother about the underlying database, usually if we are using ORM we know nothign about the underlying db, we just have to handle Java objects and this is why it's so convenient.
3. Highly stable.
4. Quite good performance.

---

### Basic CRUD Operations with EntityManager - Read

- if you want to make your db queries as fast as possible then have to search by index
- using primary keys and indexing

---

### Java Persistence Query Language (JPQL)

- JPQL - we are dealing with Java objects
- instead of selecting \* from database table we select all from Person (Java class)
- Why do need JPQL? In complicated apps we may need complicated queries, handling complicated queries is made easier with JPQL
- can customize queries
- Platform independent
- simple and robust
- don't have to know about underlyin database structure because dealing with Java classes

#### JPQL - Native SQL Queries

- useful for stored procedures
- sometimes convenient to use JPA and sometimes adviseable to use Native SQL

```java
import java.util.List;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;
import jakarta.persistence.Query;

public class App {

	public static void main(String[] args) {

		EntityManagerFactory factory = Persistence
				.createEntityManagerFactory("com.grswebservices.jpa");
		EntityManager entityManager = factory.createEntityManager();
		entityManager.getTransaction().begin();

		// JPQL Statement
		Query query = entityManager
				.createNativeQuery("SELECT * FROM person_table WHERE age BETWEEN 20 AND 40", Person.class);
//				.createQuery("SELECT p FROM Person p ORDER BY p.name ASC");
//				.createQuery("SELECT p FROM Person p WHERE p.NAME like '%el'");
//		Query query = entityManager.createQuery("SELECT p FROM Person p WHERE p.age BETWEEN 30 AND 50");

		List<Person> people = (List<Person>) query.getResultList();

		for (Person p : people)
		   System.out.println(p);

		// CRUD
		// Create
		// Student student = new Student("Anna", 56, "60");
		// Person person = new Person("Joe", "joe@gmail.com");

		// Find
//		Person person = entityManager.find(Person.class, 1);
//
//		Person p1 = new Person("Joe", "joe@gmail.com", 35);
//		Person p2 = new Person("Adam", "adam@gmail.com", 56);
//		Person p3 = new Person("Kevin", "kevin@gmail.com", 24);
//		Person p4 = new Person("Anna", "anna@gmail.com", 72);

		// entityManager.remove(person);

		// entityManager.persist(person);

//		entityManager.persist(p1);
//		entityManager.persist(p2);
//		entityManager.persist(p3);
//		entityManager.persist(p4);
//
		entityManager.getTransaction().commit();

		entityManager.close();
		factory.close();
	}

}

```

### JPQL - Named Queries

- not convenient with large application with several database related operations to mix Java code with SQL related statements.
- we can use named queries - attach / assign queries to a given class
- can reuse queries as many times as we want

```java
@Entity
@Table(name="PERSON_TABLE")
// Named Query
@NamedQuery(name="person.getAll", query="SELECT p FROM Person p")
public class Person {
	...
}

public class App {

	public static void main(String[] args) {

		EntityManagerFactory factory = Persistence
				.createEntityManagerFactory("com.grswebservices.jpa");
		EntityManager entityManager = factory.createEntityManager();
		entityManager.getTransaction().begin();

		// JPQL Statement
		Query query = entityManager
    // Named Query
				.createNamedQuery("person.getAll");

		List<Person> people = (List<Person>) query.getResultList();

		for (Person p : people)
		   System.out.println(p);

		entityManager.getTransaction().commit();

		entityManager.close();
		factory.close();
	}

}

// Hibernate:
//     select
//         p1_0.id,
//         p1_0.age,
//         p1_0.email,
//         p1_0.name
//     from
//         PERSON_TABLE p1_0
// Person [id=1, name=Joe, email=joe@gmail.com, age=35]
// Person [id=2, name=Adam, email=adam@gmail.com, age=56]
// Person [id=3, name=Kevin, email=kevin@gmail.com, age=24]
// Person [id=4, name=Anna, email=anna@gmail.com, age=72]
```

```java
public class App {

	public static void main(String[] args) {

		EntityManagerFactory factory = Persistence
				.createEntityManagerFactory("com.grswebservices.jpa");
		EntityManager entityManager = factory.createEntityManager();
		entityManager.getTransaction().begin();

		// JPQL Statement
		TypedQuery<Person> query = entityManager
				.createNamedQuery("person.getAll", Person.class);

		List<Person> people = query.getResultList();

		for (Person p : people)
		   System.out.println(p);

		entityManager.getTransaction().commit();

		entityManager.close();
		factory.close();
	}

}
```

- can assign as many queries as we want - using @NamedQueries annotation
- named queries are quite powerful, first of all because we can seperate Java code from database related code, because we just reference the named query associated with the class, and then we can set the parameters.
- bit more elegant rather than included database related SQL statements in Java code.

```java
@Entity
@Table(name="PERSON_TABLE")
@NamedQueries({
	@NamedQuery(name="person.getAll", query="SELECT p FROM Person p"),
	@NamedQuery(name="person.getPersonById", query="SELECT p FROM Person p WHERE p.id = :id"),
	@NamedQuery(name="person.getPersonByName", query="SELECT p FROM Person p WHERE p.name = :name"),

})
public class Person {
...
}


public class App {

	public static void main(String[] args) {

		EntityManagerFactory factory = Persistence
				.createEntityManagerFactory("com.grswebservices.jpa");
		EntityManager entityManager = factory.createEntityManager();
		entityManager.getTransaction().begin();

		// JPQL Statement
		TypedQuery<Person> query = entityManager
				.createNamedQuery("person.getPersonByName", Person.class);

		query.setParameter("name", "Adam");

		List<Person> people = query.getResultList();

		for (Person p : people)
		   System.out.println(p);

		entityManager.getTransaction().commit();

		entityManager.close();
		factory.close();
	}

}
```

---

### Inheritance in JPA

- Inheritance is an OOP related programming feature
- powerful because if we want to the use the same behaviour and variables in multiple classes then we can include a parent / super class and achieve code reusability more efficiently.
- However, most databases such as MySQL don't support inheritance
- JPA supports all object oriented concepts for entity persistence.
- relational database doesn't support mechanism of inheriance. So JPA is used to map the key features of inheritance in relational database model.

---

#### Inheritance Strategies

1. **Single Table strategy**

- @Inheritance(strategy = InheritanceType.SINGLE_TABLE)

2. **Joined Table strategy**

- @Inheritance(strategy = InheritanceType.JOINED)

3. **Table per class strategy**

- @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)

---

### Inheritance Strategies I - Single Table

- store every single item in a single db table

```java

@Entity
@Table(name="VEHICLE_TABLE")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "type")
public class Vehicle {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;

	private String name;

	public Vehicle() {

	}

	public Vehicle(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}

@Entity
@DiscriminatorValue(value = "C")
public class Car extends Vehicle {

	private int speed;

	public Car() {

	}

	public Car(String name, int speed) {
		super(name);
		this.speed = speed;
	}

	public int getSpeed() {
		return speed;
	}

	public void setSpeed(int speed) {
		this.speed = speed;
	}
}

@Entity
@DiscriminatorValue(value = "B")
public class Bus extends Vehicle {

	private int numOfPassengers;

	public Bus() {

	}

	public Bus(String name, int numOfPassengers) {
		super(name);
		this.numOfPassengers = numOfPassengers;
	}

	public int getNumOfPassengers() {
		return numOfPassengers;
	}

	public void setNumOfPassengers(int numOfPassengers) {
		this.numOfPassengers = numOfPassengers;
	}

}



public class App {

	public static void main(String[] args) {
		EntityManagerFactory factory = Persistence
				.createEntityManagerFactory("com.grswebservices.jpa");
		EntityManager entityManager = factory.createEntityManager();

		entityManager.getTransaction().begin();

		// make changes to the DB
		Bus bus = new Bus("Name of Bus", 100);
		Car car = new Car("Name of Car", 150);

		entityManager.persist(bus);
		entityManager.persist(car);

		entityManager.getTransaction().commit();

		entityManager.close();
		factory.close();
	}
}





```

---

#### Inheritance Strategies II - Joined Table

- jpa will create a distinct db table for every single entity
- bit more cimplicated as seprate tables for eahc entity, joined by primary key, but benefit is more memory efficient as no null values which occurs in single table database wwith entities which have different properties

---

#### Inheritance Strategies II - Table per Class

- jpa creates a database table associated with every single entity we have defined in Java but in this case these tabes are not going to be connected based on the primary key

---

### Entity Relationships - @OneToOne

#### Composition vs Inheritance

**INHERITANCE** "IS A relationship"  

```java
public Car extends Vehicle {
...
}
```

- Car "IS A" Vehicle

**COMPOSITION** "HAS A relationship"

```java
public class Employee {
	private Address address;
	...
}
```

- Employee "HAS A" Address
- a given class or object includes another object as a field variable
- this is called Composition
- "Favour Composition over Inheritance is a principle of object-oriented programming"
- One to one relation between the two entities
- every e,ploee has a single address and every address has a single employee
- store a reference to a column in the other table
- foreign key allows us to connect to indepedent database tables

---

## ManyToMany
- ManyToMany mapping represents a collection of data value associations where any number of entites can be associated with a collection of other entities.
- In a relational database, any number of rows of one entity can be referred to in a number of rows of another entity.


```sql
mysql> show tables;
+---------------------+
| Tables_in_udemy     |
+---------------------+
| address             |
| bus                 |
| car                 |
| employee            |
| hibernate_sequences |
| person              |
| person_table        |
| prof_projects       |
| professor           |
| projects            |
| student             |
| university          |
| vehicle             |
+---------------------+
13 rows in set (0.01 sec)

mysql> select * from professor;
+----+-----------------+
| id | name            |
+----+-----------------+
|  1 | Stephen Hawking |
|  2 | Albert Einstein |
+----+-----------------+
2 rows in set (0.00 sec)

mysql> select * from projects;
+----+------------------------------------+
| id | project_name                       |
+----+------------------------------------+
|  1 | Black Hole Project                 |
|  2 | Quantum Field Theory Project       |
|  3 | Thermodynamic Fluctuations Project |
+----+------------------------------------+
3 rows in set (0.00 sec)

mysql> select * from prof_projects;
+-----------+-------------+
| projectId | professorId |
+-----------+-------------+
|         1 |           1 |
|         1 |           2 |
|         2 |           1 |
|         3 |           2 |
+-----------+-------------+
4 rows in set (0.15 sec)


```

---

## Eager vs Lazy Fetch

- The basic concept of JPA is to make a duplicate copy of the database in the cache memory
- we manipulate the duplicate data
- only when it is committed using entity manager are the changes effected into the database.

---

- Eager fetch: when we search for a record and find it, we return the whole record.
- Lazy fetch: when we search for a record and if we find it we store the information that is available but do not return data.
- data will be returned only when the setter method is called.
- for example: getStudents()
- not adviseable to get huge list of students. 
- instead use lazy fetch - jpa will know the students are present but will not load the students automatically. 
- data will be loaded only when the setter method is called such as getStudents()
- lazy fetch is preferably because it is memory friendly.
- so when we instantiate a new Professor and whenever we are handling the object JPA will not load all the resarch projects. 
- default type is default FetchType.Lazy

---

## Cascading fields

- Use of the cascade annotation element can be used to propagate the effect of an operation to associated entities.
- cascade functonality is most tpyically used in parent-child relationships or in cases of composition.
- Several books may be associated with an author. What if we get rid of Author object? We should remove the book objects as well. This is why cascading came to be.
- If something should happen to the parent then JPA will delegate this effect to the children
- CascadeType.PERSIST - If persist is called on the parent object, the child will be persisted as well
- CascadeType.MERGE - child will be merged as well
- CascadeType.DETACH - child will be detahed as well
- CascadeType.REFRESH - child will be refreshed as well
- CascadeType.REMOVE - child will be removed as well
- CascadeType.ALL - all of the above mentioned
- if we call entityManager.persist() on a given object, it will be managed by EntityManager. So it will be added to the context.
- if we call entityManager.detach() it wil be detached from the context. The EntityManager no longer manages that given object.
- if we call entityManager.merge() on the detached object it will be added to the EntityManager context again, so that EntityManager can perform operations again such as refresh() and remove()

---

#### MERGE VS PERSIST
- What is the differene between merge and persist? 
- both of them add the given entity to the context
- Persist: future updates will be tracked
- Merge: a new instance is created with the copied state and this instance will be managed by EntityManager. So any changes made to the original object will not be part of the transaction.

---

## JPA Callbacks and Listeners

- when working with JPA there are several events during an entities lifecycle.
- JPA Entity Lifecycle events and how we can use annotations to hanlde callbacks and execute code when the events occur.

```java
package com.grswebservices.jpa;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PostPersist;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;

@Entity
@Table
public class Article {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	@Column(name = "article_name")
	private String article;
	
	public Article() {
		
	}
	
	public Article(String article) {
		this.article = article;
	}
	
	@PrePersist
	public void beforePersist() {
		System.out.println("Before persisting the object...");
	}
	
	@PostPersist
	public void postPersist() {
		System.out.println("After persisting the object...");
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getArticle() {
		return article;
	}

	public void setArticle(String article) {
		this.article = article;
	}
}

````

- What is so useful about this?
- say if we wanted to assign a time to the given article 


---

### Locks - Optimistic and Pessimistic


**Optimistic locking**  
- we use @Version annotation to apply optimistic locking.
- we maintain a version number for every entity obkect. The initial version of a new entity object (when it is stored in the db for the first time) is 1.
- in every transaction in which an entity object modified its version number is automatically increased by one.
- version numbers are managed internally but can be expised by defining a version field. 
- during commit JPA checks every database object that has to be updated or deleted and comapres the version number of that object in the database to the version number of the in memory object beig updated. 
- the transaction fails and OptimisitcLockException is thrown if the version number do not match, indicating thtat ht eobject has been modfied by another user since it was trieve by the current updater. 
- optimisitc locking is based on tdetecing changes on entites by checking their version ttribute, on the cotnrary pesisimitic locking nvolves lockign entites on the db level, 
- can define version attribute once were sure that each entity class must have only 1 version attribute and it must be palced int he primary table for an entity map to several tables.
- crucial not to update the version variable ourselves, 
  
  
---

## JPA vs Hibernate

- JPA = supertype / interface
- concrete implementations / vendors such as Hibernate, EcipseLink, OpenJPA
- JPA defines the behaviour without the implementation. 
- typical in software engineering - interfaces define the behaviour but don't care how it is done.
- JPA is just the specification, an interface with all the methods
- vendors do conrete implementations
- use jpa as a supertype: we xan change the vendors whenever we want.
- open-closed principle - open for extension, but closed for modification - which means if we want to change the underlying implementation, the jpa vendor, it will be extremely easy, beuase we just have to change the dependenyc in the POM.xml file, we don;t have to update the classes we have already implemented. 

- better to use import javax.persistence.Entity; rather than org.hiberate.annotations.Entity; as the latter ties you into the vendor, whereas if you use the JPA interface dont need to change all imports of every file, just change dependencies in POM

---

## Spring Framework

- released in June 2003.
- enforces programmers to use best known coding practices
- key feature: **inversion of control** principle and dependency injection
- the core module in the framework is the "inversion of control container"
- we don't instantiate classes: the framework manages this problem.

---

### About Dependency
- we want to have as few dependencies as possible: if classes and modules are independent, we can reuse them without any problem.
- depdendency injection glues classes together but keeps them as independent as possible. 

---

### SOLID PRINCIPLES

- **The Single Responsibility Principle** states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class.
- **Open/Closed Principle** - objects or entities should be open for extension but closed for modification.
- **Liskov Substitution Principle**: Every subclass or derived class should be substitutable for their base or parent class. 
- **Interface Segregation Principle**: This principle states that no client should be forced to depend on methods it does not use.
- **Dependency Inversion Principle**: High-level modules should not depend of low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. 

---

#### Dependency Inversion 
- High-level modules should not depend of low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. 
- we can make it happen with inversion of control such as dependency injection
- This is why Spring Framework came to be.
- We can handle these problems with various design patterns: template pattern, service locator pattern etc. Using Spring Framework is more convenient. 
- we can end up woth loosely coupled software architecture
- if we need to update a given class it will be easy because high level modules do not depend on low level modules.

---

#### Benefits of Spring
- We can develop enterprise applications using POJOs (instead of enterprise beans), so we do no need an EJB contains such as an application server. We can use servlet container as well. So essentially Srping framework is lightweight in comparison to Enterprise level Java Beans.
- Spring Framework makes use of the existing tehchnologies (ORM, etc)
- It has a lightweight IoC Container compared to EJB containers, so it can be v helpful when we want to deploy our applcation on computers with limited memory or limited CPU resource. 

---

#### Spring Framework Architecture
- Spring core, spring beans, and spring context = fundamental building blocks  

- Data Access/Integration
- Web
- Core container

---

- Core container - 
- Bean factory = impleentation of a factory pattern - we dont have to instantiate classes explicitly as they are handled as Beans. 
- we get access to these beans with help of context. Context module builds on solid base privedd by core and beans modules, and i a media to access any objects they find and configure
-

---


- this is how we can use Maven to fetch every single dependency - spring core, spring beans, and spring context
- then we can use an xml file to define the beans
- then we can instantiate an application context in order to get these beans whenever we want.
- sp this is the overal strucut reo f a pring application
 
 
 ---
 
#### Spring Containers
 
- Spring relies heavily on IoC: the spring conatiner helps to make this IoC.

- Creat the objects + wire them together + manage their complete lifecycle from creation to destruction + uses dependency injection to manage compositions: these are beans
- instructions + metadata (XML, annotations) --> container creates the full application!!
- 

----

### Bean Scopes

- **Singleton Scope** - Spring IoC container creates (and caches) exactly one object defined by the bean. The default scope is singleton,
	- if we get multiple instances and change a given feature, a given variable, within a given instance, then this update will be reflected in every other instance as well because essentially there is just one object under the hood.
- **Prototype Scope** - This is how we can force Spring IoC container to create a new bean instance every time a new one is needed.
- **Web-Aware Scoped** - request, session and global-session scopes.


```java
package com.grswebservices;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

	public static void main(String[] args) {
		
		// IoC container - this is where the beans are located
		ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
		
		// we do not get a NULL exception because the Spring container does the instantiation under the hood
		Student s = (Student) context.getBean("student_bean");
		s.setStudentName("Kevin");
		System.out.println(s.getStudentName());
		
		Student s2 = (Student) context.getBean("student_bean");
		System.out.println(s2.getStudentName());
	}

}
// with singleton scope s2 will be same as s

```

---

### Bean Lifecycle


